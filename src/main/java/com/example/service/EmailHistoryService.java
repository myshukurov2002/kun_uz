package com.example.service;import com.example.dto.ApiResponse;import com.example.dto.EmailHistoryDTO;import com.example.entity.EmailHistoryEntity;import com.example.exception.AppBadRequestException;import com.example.exception.ItemNotFoundException;import com.example.repository.EmailHistoryRepository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.domain.*;import org.springframework.stereotype.Service;import java.time.LocalDate;import java.time.LocalDateTime;import java.util.List;import java.util.Optional;import java.util.stream.Collectors;@Servicepublic class EmailHistoryService {    @Autowired    private EmailHistoryRepository emailHistoryRepository;    public ApiResponse create(EmailHistoryEntity entity) {        if (check(entity)) {//            if (emailHistoryRepository.existsByEmail(entity.getEmail())) {//                emailHistoryRepository.deleteByEmail(entity.getEmail());//            }            emailHistoryRepository.save(entity);            return new ApiResponse(true, "SUCCESS CREATED HISTORY!");        }        return new ApiResponse(false, "FAILED CREATED HISTORY!");    }    private EmailHistoryEntity DTO_TO_ENTITY(EmailHistoryDTO dto) {        EmailHistoryEntity entity = new EmailHistoryEntity();        entity.setEmail(dto.getEmail());        entity.setMessage(dto.getMessage());        return entity;    }    private boolean check(EmailHistoryEntity entity) {        if (entity.getMessage() == null) {            throw new AppBadRequestException("message is null found!");        }        if (entity.getEmail() == null) {            throw new AppBadRequestException("email is null found!");        }        return true;    }    public List<EmailHistoryDTO> getByEmail(String email) {        List<EmailHistoryEntity> all = emailHistoryRepository.findAllByEmail(email);        return all                .stream()                .map(this::ENTITY_TO_DTO)                .toList();    }    private EmailHistoryDTO ENTITY_TO_DTO(EmailHistoryEntity entity) {        EmailHistoryDTO dto = new EmailHistoryDTO();        dto.setEmail(entity.getEmail());        dto.setMessage(entity.getMessage());        dto.setCreatedDate(entity.getCreatedDate());        dto.setId(entity.getId());        return dto;    }    public EmailHistoryDTO getById(String id) {        Optional<EmailHistoryEntity> byId = emailHistoryRepository.findById(id);        EmailHistoryEntity entity = byId.orElseThrow(() -> {            throw new ItemNotFoundException("item not found!");        });        return ENTITY_TO_DTO(entity);    }    public List<EmailHistoryDTO> getByMessage(String message) {        List<EmailHistoryEntity> all = emailHistoryRepository.findAllByMessage(message);        return all                .stream()                .map(this::ENTITY_TO_DTO)                .toList();    }    public List<EmailHistoryDTO> getByDate(LocalDate date) {        LocalDateTime startingDate = date.atStartOfDay();        LocalDateTime endingDate = startingDate.plusDays(1).minusNanos(1);        List<EmailHistoryEntity> all = emailHistoryRepository.findAllByCreatedDateBetween(startingDate, endingDate);        return all                .stream()                .map(this::ENTITY_TO_DTO)                .toList();    }    public List<EmailHistoryDTO> getByGivenDate(LocalDate from, LocalDate to) {        LocalDateTime startingDate = from.atStartOfDay();        LocalDateTime endingDate = to.atStartOfDay();        List<EmailHistoryEntity> all = emailHistoryRepository.findAllByCreatedDateBetween(startingDate, endingDate);        return all                .stream()                .map(this::ENTITY_TO_DTO)                .toList();    }    public Page<EmailHistoryDTO> pagingById(String id, Integer page, Integer size) {        Sort sort = Sort.by("createdDate").ascending();        Pageable pageable = PageRequest.of(page, size, sort);//        Page<EmailHistoryEntity> entityPage = emailHistoryRepository.getAllById(id, pageable);//        List<EmailHistoryDTO> dtoList = entityPage//                .stream()//                .map(this::ENTITY_TO_DTO)//                .toList();        List<EmailHistoryEntity> all = emailHistoryRepository.findAll();        List<EmailHistoryDTO> emailHistoryDTOList = all                .stream()                .map(this::ENTITY_TO_DTO)                .toList();//        return new PageImpl<>(dtoList, pageable, entityPage.getTotalElements());        return new PageImpl<>(emailHistoryDTOList, pageable, emailHistoryDTOList.size());    }    public Page<EmailHistoryDTO> pagingByEmail(String email, Integer page, Integer size) {        Sort sort = Sort.by("createdDate").ascending();        Pageable pageable = PageRequest.of(page, size, sort);        Page<EmailHistoryEntity> entityPage = emailHistoryRepository.getAllByEmail(email, pageable);        List<EmailHistoryDTO> dtoList = entityPage                .stream()                .map(this::ENTITY_TO_DTO)                .toList();        return new PageImpl<>(dtoList, pageable, entityPage.getTotalElements());    }    public Page<EmailHistoryDTO> pagingByCreatedDate(LocalDate createdDate, Integer page, Integer size) {        LocalDateTime startingDate = createdDate.atStartOfDay();        LocalDateTime endingDate = startingDate.plusDays(1).minusNanos(1);        Sort sort = Sort.by("createdDate").ascending();        Pageable pageable = PageRequest.of(page, size, sort);        Page<EmailHistoryEntity> entityPage = emailHistoryRepository.getAllByCreatedDateBetween(startingDate, endingDate, pageable);        List<EmailHistoryDTO> dtoList = entityPage                .stream()                .map(this::ENTITY_TO_DTO)                .toList();        return new PageImpl<>(dtoList, pageable, entityPage.getTotalElements());    }    public Page<EmailHistoryDTO> pagingByCreatedDateBetween(LocalDate fromDate, LocalDate toDate, Integer page, Integer size) {        LocalDateTime startingDate = fromDate.atStartOfDay();        LocalDateTime endingDate = toDate.atStartOfDay();        Sort sort = Sort.by("createdDate").ascending();        Pageable pageable = PageRequest.of(page, size, sort);        Page<EmailHistoryEntity> entityPage = emailHistoryRepository.getAllByCreatedDateBetween(startingDate, endingDate, pageable);        List<EmailHistoryDTO> dtoList = entityPage                .stream()                .map(this::ENTITY_TO_DTO)                .toList();        return new PageImpl<>(dtoList, pageable, entityPage.getTotalElements());    }}